/* vim: set ft=cpp background=dark nofoldenable :
 *
 * This file is part of www.nand2tetris.org
 * and the book "The Elements of Computing Systems"
 * by Nisan and Schocken, MIT Press.
 * File name: projects/02/ALU.hdl
 *
 * The ALU (Arithmetic Logic Unit).
 * Computes one of the following functions:
 * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y,
 * x+1, y+1, x-1, y-1, x&y, x|y on two 16-bit inputs,
 * according to 6 input bits denoted zx,nx,zy,ny,f,no.
 * In addition, the ALU computes two 1-bit outputs:
 * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0;
 * if the ALU output < 0, ng is set to 1; otherwise ng is set to 0.
 *
 * Implementation: the ALU logic manipulates the x and y inputs
 * and operates on the resulting values, as follows:
 * if (zx == 1) set x = 0        // 16-bit constant
 * if (nx == 1) set x = !x       // bitwise not
 * if (zy == 1) set y = 0        // 16-bit constant
 * if (ny == 1) set y = !y       // bitwise not
 * if (f == 1)  set out = x + y  // integer 2's complement addition
 * if (f == 0)  set out = x & y  // bitwise and
 * if (no == 1) set out = !out   // bitwise not
 * if (out == 0) set zr = 1
 * if (out < 0) set ng = 1
 */

/*

## Description

There are four major components to the ALU:

1. X Preprocessing.
2. Y Preprocessing.
3. Sum/And processing.
4. Postprocessing

## Explanation

The X preprocessing uses selectors "zx" and "nx" to optionally zero and negate
the X input. Mux16 chips choose the final value which is emitted in "xbus".

The Y preprocessing chips mirror X with the output emitted to "ybus".

In the sum/and processing, both the "sum" and "and" of X and Y are calculated,
and a Mux16 chip is used to select the desired result using the value of "f".
The result of this calculation is emitted to "result".

In postprocessing, the Not16 of "result" is calculated and optionally selected
with a Mux16 and the "no" (Negate Output) signal. Registers "zr" ("zero") and
"ng" ("negative") are calculated with bitwise arithmetic.

*/

CHIP ALU {
    IN x[16], y[16],  // 16-bit inputs
       zx, // zero the x input?
       nx, // negate the x input?
       zy, // zero the y input?
       ny, // negate the y input?
       f,  // compute out = x + y (if 1) or x & y (if 0)
       no; // _n_egate the _o_ut output?

    OUT out[16], // 16-bit output
        zr, // 1 if (out == 0), 0 otherwise
        ng; // 1 if (out < 0),  0 otherwise

    PARTS:
    Not16(in=y, out=noty);

    /* Process x input. First zero, then negate. */
    Mux16(a=x, b[0..15]=false, sel=zx, out=xbus0);
    Not16(in=xbus0, out=notxbus0);
    Mux16(a=xbus0, b=notxbus0, sel=nx, out=xbus);

    /* Process y input. First zero, then negate. */
    Mux16(a=y, b[0..15]=false, sel=zy, out=ybus0);
    Not16(in=ybus0, out=notybus0);
    Mux16(a=ybus0, b=notybus0, sel=ny, out=ybus);

    /* calculate sum & bitwise-and */
    And16(a=xbus, b=ybus, out=outand);
    Add16(a=xbus, b=ybus, out=outsum);
    Mux16(a=outand, b=outsum, sel=f, out=result);

    /* apply optional "not" to output and set "ng" register
     * - "ng" is true if the number is negative (high bit is 1)
     * - also set helper circuits "outhi", "outlo" to calculate "zr"
     */
    Not16(in=result, out=notresult);
    Mux16(a=result, b=notresult, sel=no, out=out,
          out[0..7]=outlo, out[8..15]=outhi, out[15]=ng);

    /* Set zr ("zero") register:
     * - true if all output bits are zero
     * - false otherwise.
     * Or together all the bits in 'out'. If any of them are true
     * then 'out' is not zero. We need to do this in chunks because
     * there's no Or16Way chip.
     */
    Or8Way(in=outlo, out=or1);
    Or8Way(in=outhi, out=or2);
    Or(a=or1, b=or2, out=or3);
    Not(in=or3, out=zr);
}
